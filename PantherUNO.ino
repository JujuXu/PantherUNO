//affichage du logo windows
const unsigned char myBitmap [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x0f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x1f, 0x0f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x7e, 0x0f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xf2, 0x0b, 0xff, 0x07, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xe0, 0xff, 0x80, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xf0, 0x7c, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xf0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x00, 0x07, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x01, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x07, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xe0, 0x0f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0x80, 0x1f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfc, 0x00, 0x1f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x20, 0x00, 0x0f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x0f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x3e, 0x0f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x01, 0xff, 0x07, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xc1, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xe0, 0xff, 0x80, 0x07, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xf0, 0x7e, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xf0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//inclusion des librairies
#include <Ultrasonic.h> //capteurs ultrasons
#include <SFE_MMA8452Q.h> //accéléromètre
#include <splash.h>
#include <Adafruit_SSD1306.h> //écran OLED
#include <Adafruit_PWMServoDriver.h>//PWM extander
#include <Wire.h> //I2C

//définition des pins
#define trig 2 // define TrigPin
#define echo1 4 // define EchoPin.
#define echo2 7 // define EchoPin.
#define echo3 8 // define EchoPin.

#define c_force A2
#define ledforce 6 // define led force Pin.

#define ledultrason 5 //define led ultrason Pin

#define buzzer 3 // define buzzer pin.

#define In1 9 //pin moteur
#define In2 10
#define In3 11
#define In4 12
#define mot1 14 //sur extender
#define mot2 15
#define cCourantA A0 // capteurs de courant
#define cCourantB A1

//def I2C
#define adresseI2CecranOLED 0x3C
Adafruit_SSD1306 ecranOLED(128, 64, &Wire, -1);
#define adresseI2CecranOLED2 0x3D
Adafruit_SSD1306 ecranOLED2(128, 64, &Wire, -1);
//init PWM extander
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver();
//def accéléromètre
MMA8452Q accel;

//définition des ultrasons
Ultrasonic ultrasonic1(trig, echo1);
Ultrasonic ultrasonic2(trig, echo2);
Ultrasonic ultrasonic3(trig, echo3);


//variable utilisée dans le code
float courantA = 0;
float courantB = 0;
unsigned long t1 = 0; //temps mesure 
const long i1 = 200; //interval mesure
unsigned long t2 = 0; //temps sonnerie buzzer
const long i2 = 200; //interval sonnerie
bool buzzer_state = false; 
unsigned long t3; //temps d'envois des donnée capteur
const long i3 = 200; //interval envois
bool warnforce = false;
bool security = false;
int angleAlim = 100; //angle limit pour la pince
bool warnprox = false;
int bit_force; //donnée du capteur force
int force; //force calculée
int duration1; //tps de retour des ultrason
int duration2;
int duration3;
int distance1; //distance calculée en fonction du tps
int distance2;
int distance3;
int angleA = 900; //angles de base des servos
int angleB = 570;
int angleC = 1080;
int angleE = 2300;
int angleF = 1300;
int angleG = 1400;
int vit; // vitesse moteur
bool Z_pressed = false; //appuis des touches moteurs
bool Q_pressed = false;
bool S_pressed = false;
bool D_pressed = false;


//initialisation
void setup() {
  Serial.begin(9600);
  //initialisation des input
  pinMode(c_force,INPUT);
  pinMode(trig,OUTPUT);
  pinMode(buzzer,OUTPUT);
  pinMode(echo1, INPUT);
  pinMode(echo2, INPUT);
  pinMode(echo3, INPUT);
  pinMode(ledultrason,OUTPUT);
  pinMode(ledforce,OUTPUT);

  //initialisation de l'extender
  pwm.begin();
  pwm.setOscillatorFrequency(27000000);
  pwm.setPWMFreq(50); 

  //affichage de démarrage
  ecranOLED.begin(SSD1306_SWITCHCAPVCC, adresseI2CecranOLED);
  ecranOLED.clearDisplay();
  ecranOLED.drawBitmap(0, 0, myBitmap, 128, 64, WHITE);
  ecranOLED.display();
  ecranOLED.setCursor(0, 0);                                  // Déplacement du curseur en position (0,0), c'est à dire dans l'angle supérieur gauche
  ecranOLED.setTextColor(SSD1306_WHITE, SSD1306_BLACK);                 
  ecranOLED.setTextSize(1);

  ecranOLED2.begin(SSD1306_SWITCHCAPVCC, adresseI2CecranOLED2);
  ecranOLED2.clearDisplay();
  ecranOLED2.drawBitmap(0, 0, myBitmap, 128, 64, WHITE);
  ecranOLED2.display();
  ecranOLED2.setCursor(0, 0);
  ecranOLED2.setTextColor(SSD1306_WHITE, SSD1306_BLACK);                 
  ecranOLED2.setTextSize(1);

  //initialisation de l'accéléromètre
  accel.init(SCALE_2G, ODR_800);

  //son de démarrage windowsXP pour le fun
  noTone(buzzer);
  tone (buzzer, 1244);
  delay(300);
  tone (buzzer, 622);
  delay(150);
  tone (buzzer, 932);
  delay(450);
  tone (buzzer, 830);
  delay(300);
  tone (buzzer, 622);
  delay(300);
  tone (buzzer, 1244);
  delay(300);
  tone (buzzer, 932);
  delay(600);
  noTone(buzzer);

  //mise en position initiale du robot
  pwm.writeMicroseconds(0,angleA);
  pwm.writeMicroseconds(0,angleA);
  pwm.writeMicroseconds(1,angleB);
  pwm.writeMicroseconds(2,angleC);
  pwm.writeMicroseconds(3,angleE);
  pwm.writeMicroseconds(4,angleF);
  pwm.writeMicroseconds(5,angleG);
}

void loop(){
  //vérifiaction des angles des servos
  pwm.writeMicroseconds(0,angleA);
  pwm.writeMicroseconds(1,angleB);
  pwm.writeMicroseconds(2,angleC);
  pwm.writeMicroseconds(3,angleE);
  pwm.writeMicroseconds(4,angleF);
  pwm.writeMicroseconds(5,angleG);

  //mesure des capteur et vérification des dépassements
  if(millis()-t1 >= i1) {
    t1 = millis();
    capteur();
  }

  //envois des données en Sérial
  if(millis()-t3 >= i3) {
    t3 = millis();
    send();
  }

  //avertissement sonore si dépassement
  avertissement();

  if(Serial.available() > 0) {
  String data = Serial.readStringUntil('\n');

  //controle du bras
    if(data.startsWith("A")) {
      if(map(data.substring(1).toInt(),0,180,600,2400) > angleAlim && security){} //sécurité pour éviter de serrer trop la pince ou trop la déssérer
      else{
        angleA = map(data.substring(1).toInt(),0,180,600,2400);
        security = false;
        angleAlim = 100;
      }
    }
    if(data.startsWith("B")) {angleB = map(data.substring(1).toInt(),0,180,500,2300);} //mapper les données reçue de l'esp32
    if(data.startsWith("C")) {angleC = map(data.substring(1).toInt(),0,180,500,2300);} //sur les temps ON en micro seconde
    if(data.startsWith("E")) {angleE = map(data.substring(1).toInt(),0,180,500,2300);} //pour les PWM extender
    if(data.startsWith("F")) {angleF = map(data.substring(1).toInt(),0,180,700,1900);}
    if(data.startsWith("G")) {angleG = map(data.substring(1).toInt(),0,180,500,2300);}

  //controle direction
    if (data.startsWith("Z")) {Z_pressed = true; vit = map(data.substring(1).toInt(),0,100,4500,20000);} //idem que pour les servos sur les PWM des moteurs
    if (data.startsWith("Q")) {Q_pressed = true; vit = map(data.substring(1).toInt(),0,100,4500,20000);}
    if (data.startsWith("S")) {S_pressed = true; vit = map(data.substring(1).toInt(),0,100,4500,20000);}
    if (data.startsWith("D")) {D_pressed = true; vit = map(data.substring(1).toInt(),0,100,4500,20000);}
    if (data.startsWith("z")) {Z_pressed = false;} //on release to stop
    if (data.startsWith("q")) {Q_pressed = false;}
    if (data.startsWith("s")) {S_pressed = false;}
    if (data.startsWith("d")) {D_pressed = false;}
  }
  move();

  // afficheur();
}





void capteur(){
  //courant
  courantA = map(analogRead(cCourantA),0,82,0,1); //mapper la valeur de tension avec 400mV/ampère
  courantB = map(analogRead(cCourantB),0,82,0,1); //avec 5V = 1023 donc 400mV = 82
  
  //accéléromètre
  accel.read();
  // accel.cx
  // accel.cy
  // accel.cz

  //force
  bit_force = analogRead(c_force); //lecture du Bit de force
  if(bit_force<400){
    bit_force=400;
    digitalWrite(ledforce,HIGH);
    angleA=angleA-10;
    if (angleA<960){  //passage en avertissement si surcharge de force
      angleA = 960;
    }
    angleAlim = angleA;
    warnforce = true;
    security = true;
    }
  else{
    digitalWrite(ledforce,LOW);
    warnforce = false;
    }

  //force
  force = map(bit_force,400,1023,100,1);

  //distance
  distance1=ultrasonic1.read();
  distance2=ultrasonic2.read();
  distance3=ultrasonic3.read();
  if (distance1<15 || distance2<15 || distance3<15) {
    digitalWrite(ledultrason,HIGH);
    warnprox = true;
    }
  if (distance1>15 && distance2>15 && distance2>15) {
    digitalWrite(ledultrason,LOW);
    warnprox = false;
  }
  if (distance1>400 || distance1<0) {distance1=400;}
  if (distance2>400 || distance2<0) {distance2=400;}
  if (distance3>400 || distance3<0) {distance3=400;}
}

void avertissement(){
  if(warnprox == false && warnforce == false){
    noTone(buzzer);
  }
  if(warnforce==true || warnprox==true){
    if(millis() - t2 >= i2){
      t2 = millis();
      if(buzzer_state == false){
        tone(buzzer,150);
        buzzer_state = true;
      }
      else{
        noTone(buzzer);
        buzzer_state = false;
      }
    }
  }
}

void move(){
    // déplacement diagonal
  if(Z_pressed && Q_pressed){
    // Serial.println("ZQ");
    digitalWrite(In1, HIGH);
    digitalWrite(In2, LOW);
    digitalWrite(In3, HIGH);
    digitalWrite(In4, LOW);
    pwm.writeMicroseconds(mot1, vit);
    pwm.writeMicroseconds(mot2, vit/2);
  }

  else if(Z_pressed && D_pressed){
    // Serial.println("ZD");
    digitalWrite(In1, HIGH);
    digitalWrite(In2, LOW);
    digitalWrite(In3, HIGH);
    digitalWrite(In4, LOW);
    pwm.writeMicroseconds(mot1, vit/2);
    pwm.writeMicroseconds(mot2, vit);
  }

  else if(S_pressed && D_pressed){
    // Serial.println("SD");
    digitalWrite(In1, LOW);
    digitalWrite(In2, HIGH);
    digitalWrite(In3, LOW);
    digitalWrite(In4, HIGH);
    pwm.writeMicroseconds(mot1, vit/2);
    pwm.writeMicroseconds(mot2, vit);
  }

  else if(S_pressed && Q_pressed){
    // Serial.println("SQ");
    digitalWrite(In1, LOW);
    digitalWrite(In2, HIGH);
    digitalWrite(In3, LOW);
    digitalWrite(In4, HIGH);
    pwm.writeMicroseconds(mot1, vit);
    pwm.writeMicroseconds(mot2, vit/2);
  }

    //déplacement classique
  else if(Z_pressed){
    // Serial.println(vit);
    digitalWrite(In1, HIGH);
    digitalWrite(In2, LOW);
    digitalWrite(In3, HIGH);
    digitalWrite(In4, LOW);
    pwm.writeMicroseconds(mot1, vit);
    pwm.writeMicroseconds(mot2, vit);
    }

  else if(Q_pressed){
    // Serial.println("Q");
    digitalWrite(In1, HIGH);
    digitalWrite(In2, LOW);
    digitalWrite(In3, LOW);
    digitalWrite(In4, HIGH);
    pwm.writeMicroseconds(mot1, vit);
    pwm.writeMicroseconds(mot2, vit);
    }

  else if(S_pressed){
    // Serial.println("S");
    digitalWrite(In1, LOW);
    digitalWrite(In2, HIGH);
    digitalWrite(In3, LOW);
    digitalWrite(In4, HIGH);
    pwm.writeMicroseconds(mot1, vit);
    pwm.writeMicroseconds(mot2, vit);
    }

  else if(D_pressed){
    // Serial.println("D");
    digitalWrite(In1, LOW);
    digitalWrite(In2, HIGH);
    digitalWrite(In3, HIGH);
    digitalWrite(In4, LOW);
    pwm.writeMicroseconds(mot1, vit);
    pwm.writeMicroseconds(mot2, vit);
    }


  //arrêt
  else {
    vit = 0;
    digitalWrite(In1, LOW);
    digitalWrite(In2, LOW);
    digitalWrite(In3, LOW);
    digitalWrite(In4, LOW);
    pwm.writeMicroseconds(mot1,vit);
    pwm.writeMicroseconds(mot2,vit);
  }
}

void send(){
  Serial.println("PS_LEFT="+String(distance1));
  Serial.println("PS_FRONT="+String(distance2));
  Serial.println("PS_RIGHT="+String(distance3));

  Serial.print("COURANTA=");
  Serial.println(courantA,3);
  Serial.print("COURANTB=");
  Serial.println(courantB,3);
  
  Serial.print("ACCELX=");
  Serial.println(accel.cx,3);
  Serial.print("ACCELY=");
  Serial.println(accel.cy,3);
  Serial.print("ACCELZ=");
  Serial.println(accel.cz,3);

  if (warnforce) {
  Serial.println("warnforce");
  }
  if (warnprox) {
  Serial.println("warnprox");
  }
}

void afficheur(){
  ecranOLED.clearDisplay();  
  ecranOLED.setCursor(0, 0); 
  //print accélération
  ecranOLED.print (" ");
  ecranOLED.print(accel.cx, 3);
  ecranOLED.print (" ");
  ecranOLED.print(accel.cy, 3);
  ecranOLED.print (" ");
  ecranOLED.println(accel.cz, 3);
  //print distance
  ecranOLED.print(distance1);
  ecranOLED.print (" ");
  ecranOLED.print(distance2);
  ecranOLED.print (" ");
  ecranOLED.println(distance3);
  //print le % force
  ecranOLED.print("force :");
  ecranOLED.print(force);
  ecranOLED.println(" %");
  //print des valeurs d'angles
  ecranOLED.print(angleA);
  ecranOLED.print (" ");
  ecranOLED.print(angleB);
  ecranOLED.print (" ");
  ecranOLED.println(angleC);
  ecranOLED.print(angleE);
  ecranOLED.print (" ");
  ecranOLED.print(angleF);
  ecranOLED.print (" ");
  ecranOLED.println(angleG);
  //print vitesse
  ecranOLED.print("v1 : ");
  ecranOLED.print(vit);
  ecranOLED.print(" ");
  ecranOLED.print("v2 : ");
  ecranOLED.println(vit);
  //print courant
  ecranOLED.print("A1 : ");
  ecranOLED.print(courantA);
  ecranOLED.print("  A2 : ");
  ecranOLED.println(courantB);

  ecranOLED.display();                            // Transfert le buffer à l'écran*/
}